// Generated by CoffeeScript 1.4.0
(function() {
  var Versions, dummyEasel, _ref;

  if ((_ref = window.tacit) == null) {
    window.tacit = {};
  }

  dummyEasel = (function() {

    function dummyEasel(versions, i, project) {
      this.versions = versions;
      this.i = i;
      this.project = project;
      null;
    }

    dummyEasel.prototype.mouseDown = function(easel, eventType, mouseLoc, object) {
      var structure;
      if (window.triggers.load != null) {
        window.triggers.load();
      }
      structure = new tacit.Structure(this.versions.history[this.i].sketch.structure);
      structure.solve();
      this.project.actionQueue = [structure];
      undoredo.pointer = 0;
      structure = new tacit.Structure(structure);
      structure.last_edit = this.versions.history[this.i].sketch.structure.last_edit;
      this.versions.project.easel.pad.load(structure);
      this.versions.project.easel.pad.sketch.feapad = window.feapadpad;
      this.versions.project.easel.pad.sketch.updateDrawing();
      this.versions.project.easel.pad.sketch.fea();
      this.versions.project.onChange();
      window.log += ("# at " + (new Date().toLocaleString()) + ", a new structure of weight " + structure.lp.obj + " with " + project.easel.pad.sketch.structure.nodeList.length + " nodes and " + project.easel.pad.sketch.structure.beamList.length + " beams was created by the load tool\n") + structure.strucstr + "\n";
      if (structure.last_edit === window.usernum) {
        this.saveToDatabase(structure, "load from self");
      } else {
        this.saveToDatabase(structure, "load from teammate");
      }
      return false;
    };

    dummyEasel.prototype.allowPan = function() {
      return false;
    };

    dummyEasel.prototype.mouseUp = function(easel, eventType, mouseLoc, object) {
      return false;
    };

    dummyEasel.prototype.mouseMove = function(easel, eventType, mouseLoc, object) {
      return false;
    };

    dummyEasel.prototype.saveToDatabase = function(structure, tool) {
      var beam, beamObjs, beams, coordinatesData, data, end, fixedData, forceData, immovable, node, nodeObjs, nodes, size, start, _i, _j, _len, _len1;
      beams = structure.strucstr.split(/\r?\n/);
      beamObjs = [];
      for (_i = 0, _len = beams.length; _i < _len; _i++) {
        beam = beams[_i];
        data = beam.split(/\|/);
        size = data[1];
        data = data[0].split(/\>\>/);
        start = data[0].split(/\,/);
        end = data[1].split(/\,/);
        immovable = data[2] === "true";
        beamObjs.push({
          size: size.replace(/^\s+|\s+$/g, ""),
          start_x: start[0].replace(/^\s+|\s+$/g, ""),
          start_y: start[1].replace(/^\s+|\s+$/g, ""),
          start_z: start[2].replace(/^\s+|\s+$/g, ""),
          end_x: end[0].replace(/^\s+|\s+$/g, ""),
          end_y: end[1].replace(/^\s+|\s+$/g, ""),
          end_z: end[2].replace(/^\s+|\s+$/g, ""),
          immovable: immovable
        });
        nodeObjs = [];
        nodes = structure.nodestr.split(/\r?\n/);
        for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
          node = nodes[_j];
          data = node.split(/\|/);
          coordinatesData = data[0].split(" ");
          fixedData = data[1].split(" ");
          forceData = data[2].split(" ");
          immovable = data[3] === "true";
          nodeObjs.push({
            x: coordinatesData[0],
            y: coordinatesData[1],
            z: coordinatesData[2],
            fixed: {
              x: fixedData[0],
              y: fixedData[1],
              z: fixedData[2]
            },
            force: {
              x: forceData[0],
              y: forceData[1],
              z: forceData[2]
            },
            immovable: immovable
          });
        }
      }
      return firebase.database().ref(window.sessionid + "/" + window.usernum + "/" + window.problem_order + '/structures/').push().set({
        timestamp: new Date().toLocaleString()({
          weight: structure.lp.obj,
          nodes: project.easel.pad.sketch.structure.nodeList.length,
          beams: project.easel.pad.sketch.structure.beamList.length,
          tool: tool,
          beamList: beamObjs,
          nodeList: nodeObjs,
          beamsList: beamObjs,
          nodeList: nodeObjs
        })
      });
    };

    return dummyEasel;

  })();

  Versions = (function() {

    function Versions(project, newVersion) {
      this.project = project;
      this.htmlLoc = "#HistorySketchesView";
      this.previewHtmlLoc = "#PreviewHistory";
      this.history = [];
      this.newVersion(newVersion);
    }

    Versions.prototype.newVersion = function(structure, newVersion) {
      var beam, beamObjs, beams, coordinatesData, data, easel, end, fixedData, forceData, genhelper, immovable, node, nodeObjs, nodes, pad, saved, size, start, versionObj, _i, _j, _len, _len1, _ref1;
      if (newVersion) {
        if (!(structure != null)) {
          structure = new tacit.Structure(this.project.easel.pad.sketch.structure);
        }
        if ((_ref1 = window.log) == null) {
          window.log = "";
        }
        window.log += "# saved at " + (new Date().toLocaleString()) + " \n";
        this.project.easel.pad.sketch.fea();
        beams = structure.strucstr.split(/\r?\n/);
        beamObjs = [];
        for (_i = 0, _len = beams.length; _i < _len; _i++) {
          beam = beams[_i];
          data = beam.split(/\|/);
          size = data[1];
          data = data[0].split(/\>\>/);
          start = data[0].split(/\,/);
          end = data[1].split(/\,/);
          immovable = data[2] === "true";
          beamObjs.push({
            size: size.replace(/^\s+|\s+$/g, ""),
            start_x: start[0].replace(/^\s+|\s+$/g, ""),
            start_y: start[1].replace(/^\s+|\s+$/g, ""),
            start_z: start[2].replace(/^\s+|\s+$/g, ""),
            end_x: end[0].replace(/^\s+|\s+$/g, ""),
            end_y: end[1].replace(/^\s+|\s+$/g, ""),
            end_z: end[2].replace(/^\s+|\s+$/g, ""),
            immovable: immovable
          });
        }
        nodeObjs = [];
        nodes = structure.nodestr.split(/\r?\n/);
        for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
          node = nodes[_j];
          data = node.split(/\|/);
          coordinatesData = data[0].split(" ");
          fixedData = data[1].split(" ");
          forceData = data[2].split(" ");
          immovable = data[3] === "true";
          nodeObjs.push({
            x: coordinatesData[0],
            y: coordinatesData[1],
            z: coordinatesData[2],
            fixed: {
              x: fixedData[0],
              y: fixedData[1],
              z: fixedData[2]
            },
            force: {
              x: forceData[0],
              y: forceData[1],
              z: forceData[2]
            },
            immovable: immovable
          });
        }
        structure.solve();
        structure.last_edit = window.usernum;
        firebase.database().ref(window.sessionid + "/" + window.usernum + "/" + window.problem_order + '/events/').push().set({
          type: "save",
          timestamp: new Date().toLocaleString(),
          nodes: nodeObjs.length,
          beams: beamObjs.length,
          nodeList: nodeObjs,
          beamList: beamObjs,
          historyLength: this.history.length,
          weight: structure.lp.obj,
          last_edit: window.usernum
        });
        versionObj = d3.select(this.htmlLoc).append("div").attr("id", "ver" + window.usernum + "-" + this.history.length).classed("ver", true);
        easel = new dummyEasel(this, this.history.length, this.project);
        versionObj.append("div").attr("id", "versvg" + window.usernum + "-" + this.history.length).classed("versvg", true);
        easel.weightDisplay = versionObj.append("div").classed("verwd", true)[0][0];
        pad = new tacit.Pad(easel, "#versvg" + window.usernum + "-" + this.history.length, 50, 50, structure);
        pad.load(structure, genhelper = false);
        pad.sketch.nodeSize = 0;
        pad.sketch.showforce = false;
        pad.sketch.updateDrawing();
        this.history.push(pad);
        structure.solve();
        pad.sketch.fea();
        saved = Math.round(pad.sketch.structure.lp.obj / 100);
        if (saved <= $("#bestweight").text().substr(1)) {
          $("#bestweight").text("$" + saved);
          $("#bestcontainer").css("display", "");
          if (window.triggers.beat != null) {
            return window.triggers.beat();
          }
        }
      }
    };

    Versions.prototype.updatePreviewHistory = function(structure) {
      var genhelper, previewEasel, previewPad, previewVersionObj;
      if (!(structure != null)) {
        structure = new tacit.Structure(this.project.easel.pad.sketch.structure);
      }
      this.project.easel.pad.sketch.fea();
      previewVersionObj = d3.select("#PreviewHistory").append("div").attr("id", "ver" + window.partnernum + "-" + structure.historyLength).classed("ver", true);
      previewEasel = new dummyEasel(this, structure.historyLength, this.project);
      previewVersionObj.append("div").attr("id", "versvg" + window.partnernum + "-" + structure.historyLength).classed("versvg", true);
      previewEasel.weightDisplay = previewVersionObj.append("div").classed("verwd", true)[0][0];
      previewEasel.weightDisplay.innerText = "\$" + Math.round(structure.lp.obj / 100);
      previewPad = new tacit.Pad(previewEasel, "#versvg" + window.partnernum + "-" + structure.historyLength, 50, 50, structure);
      previewPad.load(structure, genhelper = false);
      previewPad.sketch.nodeSize = 0;
      previewPad.sketch.showforce = false;
      previewPad.sketch.updateDrawing();
      this.history.push(previewPad);
      structure.solve();
      return previewPad.sketch.fea();
    };

    Versions.prototype.save = function(structure) {
      if (window.triggers.save != null) {
        window.triggers.save();
      }
      if (this.project.actionQueue.length > 1 || (structure != null)) {
        return this.newVersion(structure, true);
      }
    };

    return Versions;

  })();

  window.tacit.Versions = Versions;

}).call(this);
